<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单调栈及其应用]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%8D%95%E8%B0%83%E6%A0%88%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[问题引入： hdu 1506 最大矩形 题意：给你一个数组表示一个宽为1的长方形的高度，求被这块区域覆盖的最大矩形面积。 做法1：分治 总问题（l,r), 有3个子问题： 左边最大矩形 右边最大矩形 跨越左右区间的最大矩形 左右直接可以递归，重点在于如何在线性时间内求出第3个子问题：思考枚举左右端点，那么复杂度就是n / 2 * n / 2， 失去了分治的意义。但是我们在枚举左端点的时候，可以想到它的高度肯定只能变小而不能增大（因为肯定要经过前面枚举过来的高度），所以枚举右边的时候并不是每个左端点都要让右边重新从中间开始枚举，而是只会不断向右扩大。所以左右都是线性扫描，就是n. 总的时间复杂度O(n) = 2 O(n / 2) + n; 最后就是O(n) = n + n log(n); 代码……恩，我还没过…… 做法2：单调栈 用单调栈O（n）的算法找出每个点向左第一个小于它的点，向右找出第一个小于它的值。就是找到一个以该点为最小值的最大区间。 单调栈 单调栈的用途比较固定：对每个数可以求出八个数，左边第一个小于该数的位置，和第一个小于等于该数的位置，还有右边，还有大于。 具体演示单调栈原理过程：有道云博客 模板：（求左区间第一个比它小的坐标位置） 123456789101112s.push(0);h[0] = -1; //这2步很重要for (int i=1; i&lt;=n; ++i)&#123; scanf("%lld", &amp;h[i]); while (!s.empty() &amp;&amp; h[s.top()] &gt;= h[i]) s.pop(); l[i] = s.top() + 1; //如果没有上面那两句，这里当s为空时就没有top s.push(i);&#125; 求右区间第一个比它小的坐标位置： 12345678910s.push(n+1);h[n+1] = -1;for (int i=n; i&gt;=1; --i)&#123; while (!s.empty() &amp;&amp; h[s.top()] &gt;= h[i]) s.pop(); r[i] = s.top() - 1; s.push(i);&#125; 有了这两个模板就可以过问题引入的那个问题啦。 单调栈应用思考：给出一个n行m列的网格，每个格子是红色或者黑色的。求出最大的红色矩形。（0 &lt; n , m &lt; 1000) 解答： n只有1000，试着枚举下边界，这样再思考如何在这个下边界确定的情况下在O(n)时间内求出最大红色矩形面积。 对于m列，每一列都可以从下边界开始扩展红色区域，碰到黑色区域就停止，这样就给出了一个红色区域，那么此时就将问题转化为了求被这个红色区域覆盖的最大矩形了。哇，那不就和问题导入的那个问题一样了嘛。 当然这里还有个问题就是每一行每一列我们都要去扩，去扩的时候又要往上遍历，最大就是n m n.但是其实没有必要每一行都去扩， 把上一行的状态记录下来就可以直接扩展到现在这一行的状态啦。 或者直接dp做也是可以的。（等我写完再补……） 应用SPOJ min_sub Largest Submatrix (vj 链接) 二分 单调栈 题目大意：给你一个R C的矩形，（ R (R ≤ 1000), C (C ≤ 1000)），还有一个K (K ≤ R C)， 求一个矩阵，面积&gt;=K, 并且使得这个矩阵的最小值是最大的。矩阵里的数0 &lt;= M &lt;= $10^9$ 当一个问题是求解方案的情况，并且它的答案在一个区间里面，都应该想到可以用二分来把一个求解性问题转化成一个验证性问题。我原来想过二分，然后智障的觉得 n log(x)会T。TAT. 解题思路： 答案区间肯定在[0, $10^9$],然后二分一个矩阵的最小值为x，然后判断是否存在一个矩阵面积大于等于K并且最小值&gt;=x.如果满足条件，也就是说这个值还可以再大一点，即在右区间，这是可能取到的情况，所以这时候我选择的二分模型就是左闭右开。 然后是怎么判断是否存在一个矩阵面积大于等于K并且最小值&gt;=x。因为R只有1000，所以试着枚举下边界，对下边界的这一行，对每一列考虑值是否&gt;=x，&gt;=x的格子可以取，但是小于x的格子就不能选择。然后再次神奇的发现选择二分后又变成了上面那道思考题的模型啦。 这里还有个二分优化（虽然我没有用），就是如果觉得1-$10^9$二分不够优,可以把矩阵元素排序后再矩阵元素的值里选择答案二分。 代码流程： 输入矩阵 二分满足条件矩阵最小值的最大值 根据这个值写个check函数去判断此时满足这个条件的最大矩阵面积，这里写个单调栈的函数来求最大矩阵面积，如果这个最大面积&gt;=k,则返回true,否则返回false. 如果判断成功，则更新答案。 主要代码： 12345678910111213141516171819202122bool check(int x)&#123; memset(dp, 0, sizeof(dp)); y = 0; for (int i=1; i&lt;=R; ++i) &#123; for (int j=1; j&lt;=C; ++j) &#123; if (a[i][j] &gt;= x) dp[j] += 1; else dp[j] = 0; &#125; //算出所有的高度后 monotonic_stack(); //这里是算最大面积的函数 y = max(y, ans); //不断更新这个x下的面积最大值 &#125; if (y &gt;= K) return true; else return false;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;typedef long long llong;const int maxn = 1005;int a[maxn][maxn];int l[maxn]; //存id求面积int r[maxn];int dp[maxn]; //存此时的高度stack &lt;int&gt; s;int R, C, K;int ans, ret, y;void monotonic_stack()&#123; //memset(l, 0, sizeof(l)); //memset(r, 0, sizeof(r)); //for (int i=1; i&lt;=C; ++i) // printf("dp[%d] = %d\n", i, dp[i]); while (!s.empty()) s.pop(); s.push(0); dp[0] = -1; for (int i=1; i&lt;=C; ++i) &#123; while (!s.empty() &amp;&amp; dp[s.top()] &gt;= dp[i]) s.pop(); l[i] = s.top() + 1; //printf("l[%d]=%d\n", i, l[i]); s.push(i); &#125; while (!s.empty()) s.pop(); s.push(C+1); dp[C+1] = -1; for (int i=C; i&gt;=1; --i) &#123; while (!s.empty() &amp;&amp; dp[s.top()] &gt;= dp[i]) s.pop(); r[i] = s.top() - 1; s.push(i); &#125; ans = 0; //单次里的最大值 for (int i=1; i&lt;=C; ++i) &#123; //printf("l[%d]=%d r[%d]=%d\n", i, l[i], i, r[i]); int tmp = (r[i] - l[i] + 1) * dp[i]; //printf("tmp=%d\n", tmp); ans = max(tmp, ans); &#125; //return res;&#125;bool check(int x)&#123; //printf("x=%d\n", x); memset(dp, 0, sizeof(dp)); y = 0; for (int i=1; i&lt;=R; ++i) &#123; for (int j=1; j&lt;=C; ++j) &#123; if (a[i][j] &gt;= x) dp[j] += 1; else dp[j] = 0; &#125; //算出所有的高度后 monotonic_stack(); y = max(y, ans); &#125; if (y &gt;= K) return true; else return false;&#125;int solve()&#123; int l = 0, r = 1000000001; //int l=0, r=10; while (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) //满足条件，答案还可以更大一点 &#123; l = mid; ret = y; &#125; else r = mid; &#125; return l;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d %d %d", &amp;R, &amp;C, &amp;K); for (int i=1; i&lt;=R; ++i) for (int j=1; j&lt;=C; ++j) scanf("%d", &amp;a[i][j]); int max_min = solve(); printf("%d %d\n", max_min, ret); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
</search>
